package com.tedu.oop.basic;

public class InnerTest {
    public static void main(String[] args) {
        //实例化餐厅对象
       /* Kitchen K = new Kitchen("同福客栈","郭芙蓉","李大嘴");
        //客人点菜：
        System.out.println(K.order("宫保鸡丁"));*/
        //结论：内部类一般不在外部类实例化对象
        //内部类对象仅供外部类中使用。
        //其他使用者，无需知道实现细节
        /*匿名内部类的测试*/
        //为了保证运行时，动态选择厨师，做不同的菜
        //指向对象的变量必须使用父类型
        //需要一位川菜厨子
       /* Cook cook=new sichuan("川菜厨子");
        cook.cook();
        //又需要一位鲁菜厨子
        Cook cook1=new shandong("鲁菜厨子");
        cook1.cook();*/
        //问题：无法确定运行时，厨师会哪种菜
        //可能性非常多，无法尽数
        //解决：使用匿名内部类，一个具体的实现类都不定义
        //    随用，随时定义
        //  用法：使用父类型变量，实例化一个父类类型对象
        //比如：做“醉虾”
        //  有需要做“辣子鸡”
       Cook cook = new Cook("鲁菜师傅"){
           //编译错误1:因为匿名内部类第一件事就是实例化父类型变量
           //          就必须调用父类型构造方法
           //编译错误2：匿名内部类第二件事就是继承父类型
           // 并实现父类型中的抽象方法
           public void cook() {
               buy();
                              //name属性继承自父类型
               //
               System.out.println(name+"做醉虾....");
           }
           //匿名内部类可以定义自己的方法
           public void buy(){

               System.out.println("去市场买虾.....");
           }

       };
       //匿名内部类仅实例化一个对象使用匿名内部类都要是使用对象调用
        cook.cook();
         //匿名内部类其实是一句话办三件事：
        //  1、调用父类型的构造方法实例化一个父类型的对象
        //  2、因为父类型是接口或抽象类，不能直接实例化
        //     其实匿名内部类是继承父类型，实现父类型，并第一自己的实现
        //  3、以相匿名内部类中也可以包含普通的方法定义，方法之间同样也可互调用
        //优缺点：
        //优点：非常的灵活，没有剧本，想怎么实现就怎么实现
        //缺点：类的定义不便于重用，不便于大项目的维护。
    }
}
